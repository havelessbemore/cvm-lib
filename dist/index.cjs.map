{
  "version": 3,
  "sources": ["../src/index.ts", "../src/is.ts", "../src/capacity.ts", "../src/cvm.ts"],
  "sourcesContent": ["export { type CVMConfig } from \"./cvmConfig\";\n\nexport { calculateCapacity } from \"./capacity\";\n\nexport { CVM } from \"./cvm\";\n", "/**\n * Returns `true` if the value is between 0 and 1, `false` otherwise.\n *\n * @param value - The value.\n */\nexport function isFraction(value: unknown): value is number {\n  return typeof value === \"number\" && value > 0 && value < 1;\n}\n\n/**\n * Returns `true` if the value is a positive number, `false` otherwise.\n *\n * @param value - The value.\n */\nexport function isPositive(value: unknown): value is number {\n  return typeof value === \"number\" && value > 0;\n}\n\n/**\n * Returns `true` if the value is a positive integer, `false` otherwise.\n *\n * @param value - The value.\n */\nexport function isPositiveInt(value: unknown): value is number {\n  return Number.isInteger(value) && (value as number) > 0;\n}\n", "import { isFraction, isPositive } from \"./is\";\n\n/**\n * Calculates the space required to estimate the number of\n * distinct values in a set with a given accuracy and confidence.\n *\n * @param n - The total number of values in the set, or an estimate if unknown.\n *\n * - Should be a positive value.\n * - If unknown, an overestimate is better, but results in more space.\n *\n * @param epsilon - The relative error. Controls accuracy.\n *\n * - Should be between 0 and 1.\n * - Smaller values equal more accuracy but more space.\n * - Defaults to `0.05` (i.e. 95% accuracy; estimates can range within \u00B15% of the true value).\n *\n * @param delta - The probability an estimate is not within expected accuracy. Controls confidence.\n *\n * - Should be between 0 and 1.\n * - Smaller values equal higher confidence but more space.\n * - Defaults to `0.01` (i.e. 99% confidence; there is a 1% chance an estimate is outside the expected accuracy range).\n *\n * @returns The calculated capacity.\n */\nexport function calculateCapacity(\n  n: number,\n  epsilon = 0.05,\n  delta = 0.01,\n): number {\n  // Sanitize inputs\n  if (!isPositive(n)) {\n    throw new RangeError(\"Invalid n\");\n  }\n  if (!isFraction(epsilon)) {\n    throw new RangeError(\"Invalid epsilon\");\n  }\n  if (!isFraction(delta)) {\n    throw new RangeError(\"Invalid delta\");\n  }\n  // Calculate value\n  return Math.min(n, Math.ceil(Math.log2(n / delta) / epsilon ** 2));\n}\n", "import { CVMConfig } from \"./cvmConfig\";\nimport { isFraction, isPositiveInt } from \"./is\";\n\n/**\n * Estimates the number of distinct values within a set\n * using a simple and space-efficient sampling strategy.\n *\n * @see {@link https://www.quantamagazine.org/computer-scientists-invent-an-efficient-new-way-to-count-20240516/ | Nadis, S. (2024, May 16). Computer Scientists Invent an Efficient New Way to Count. Quanta Magazine.} for a summary and example.\n * @see {@link https://arxiv.org/pdf/2301.10191v2 | Chakraborty, S., Vinodchandran, N. V., & Meel, K. S. (2023). Distinct Elements in Streams: An Algorithm for the (Text) Book} for the source paper.\n */\nexport class CVM<T> {\n  /**\n   * The maximum number of samples in memory.\n   */\n  protected _capacity: number;\n\n  /**\n   * The random number generator function.\n   */\n  protected _randomFn: () => number;\n\n  /**\n   * The current sample rate.\n   */\n  protected _rate: number;\n\n  /**\n   * The given sample rate.\n   */\n  protected _sampleRate: number;\n\n  /**\n   * The set of samples in memory.\n   */\n  protected _samples: Set<T>;\n\n  /**\n   * Creates an instance of the CVM algorithm.\n   *\n   * @param capacity - The maximum number of samples in memory.\n   */\n  constructor(capacity: number);\n  /**\n   * Creates an instance of the CVM algorithm.\n   *\n   * @param config - Configuration options.\n   */\n  constructor(config: CVMConfig);\n  constructor(config: number | CVMConfig) {\n    // Initialize with defaults\n    this._capacity = 1;\n    this._rate = 1;\n    this._randomFn = Math.random;\n    this._sampleRate = 0.5;\n    this._samples = new Set();\n\n    // Apply capacity\n    if (typeof config === \"number\") {\n      this.capacity = config;\n      return;\n    }\n\n    // Apply config object\n    this.capacity = config.capacity;\n    config.sampleRate != null && (this.sampleRate = config.sampleRate);\n    config.randomFn != null && (this.randomFn = config.randomFn);\n  }\n\n  /**\n   * Gets capacity.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   * Sets capacity. Should be a positive integer.\n   */\n  protected set capacity(capacity: number) {\n    if (!isPositiveInt(capacity)) {\n      throw new RangeError(`Invalid capacity`);\n    }\n    this._capacity = capacity;\n  }\n\n  /**\n   * Gets the random number generator function.\n   */\n  get randomFn(): () => number {\n    return this._randomFn;\n  }\n\n  /**\n   * Sets the random number generator function, which should return values between 0 and 1.\n   */\n  set randomFn(randomFn: () => number) {\n    this._randomFn = randomFn;\n  }\n\n  /**\n   * Gets the sample rate.\n   */\n  get sampleRate(): number {\n    return this._sampleRate;\n  }\n\n  /**\n   * Sets the sample rate. Should be between 0 and 1.\n   */\n  protected set sampleRate(sampleRate: number) {\n    if (!isFraction(sampleRate)) {\n      throw new RangeError(`Invalid sample rate`);\n    }\n    this._sampleRate = sampleRate;\n  }\n\n  /**\n   * Gets the current number of samples in memory.\n   */\n  get size(): number {\n    return this._samples.size;\n  }\n\n  /**\n   * Adds a value to the CVM.\n   *\n   * @param value - The value to be added.\n   *\n   * @returns The CVM instance.\n   */\n  add(value: T): this {\n\n    // Ignore / remove value if not sampled\n    if (this._randomFn() >= this._rate) {\n      this._samples.delete(value);\n      return this;\n    }\n\n    // Add sample\n    this._samples.add(value);\n\n    // While at capacity\n    while (this._samples.size >= this._capacity) {\n\n      // Reduce samples to within capacity\n      for (const value of this._samples) {\n        if (this._randomFn() >= this._sampleRate) {\n          this._samples.delete(value);\n        }\n      }\n\n      // Update current sampling rate\n      this._rate *= this._sampleRate;\n    }\n\n    return this;\n  }\n\n  /**\n   * Clears / resets the CVM.\n   */\n  clear(): void {\n    this._rate = 1;\n    this._samples.clear();\n  }\n\n  /**\n   * Gets the estimated number of distinct values.\n   */\n  estimate(): number {\n    return this._samples.size / this._rate;\n  }\n}\n"],
  "mappings": "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",
  "names": ["value"]
}
